## 理解 JS 闭包

可以在一个函数外访问函数中的局部变量，把这些变量用闭包的形式放在函数中能避免污染。

有三种作用域：

- 全局作用域
- 本地/函数作用域
- 块级作用域：将变量的作用域限制为给定的括号块。函数和条件都被看作块，执行完后，ES6销毁块级变量的作用域，作用域进入全局。

当某个函数被调用的时候，会创建一个执行环境（execution context）及相应的作用域链。然后使用 arguments 和其他命名参数的值来初始化函数的活动对象（activation object）。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位……，直至作为作用域链终点的全局执行环境。

匿名函数从 A（）中被返回后，它的作用域链被初始化为包含A（）函数的活动对象和全局变量对象。因此，匿名函数可以访问在函数A（）中定义的所有变量。**更重要的是函数A（）执行完毕后，不会被销毁，因为匿名函数的作用域链仍在引用这个活动对象。当函数A（）返回后，其执行环境的作用域链会被销毁，但它的活动对象仍会留在内存中，直至匿名函数被销毁。**

#### 闭包与变量
因为闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存，过度使用闭包会导致内存占用过多。

```javascript
function a(){
    var result = new Array();
    for(var i=0;i<10;i++){
        result[i] = function(){
            return i;
        }
    }
    return result;
}
```
以上的函数我们期望返回的是一个包含 0-9 的数组，但由于闭包保存的是整个变量对象，都引用的是同一个变量 **i**，并直接把闭包赋值给了数组。
```javascript
function b(){
    var result = new Array();
    for(var i=0;i<10;i++){
		result[i] = function(num){
            return function(){
                return num;
            }
        }
    }
}
```
修改后的函数新增了匿名函数，并将立即执行后的结果复制给数组。匿名函数有一个参数**num**，即最终函数要返回的值，在每次调用匿名函数时，都传入了变量**i**，并将当前**i**的值复制给参数**num**。在匿名函数的内部，又创建了一个访问**num**的闭包。